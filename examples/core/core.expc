haskell {

(>>>) :: Bits a => a -> Int -> a
(>>>) = shiftR

(<<<) :: Bits a => a -> Int -> a
(<<<) = shiftL

type Int8 = Unsigned 8
type PC = Unsigned 5

type InstructionWord = Unsigned 8

type RegID = Unsigned 2
type Immediate = Unsigned 5

data Instruction
    = ReadFIFO RegID
    | WriteFIFO RegID
    | Add RegID RegID RegID
    | Move RegID RegID
    | Branch RegID RegID
    | LoadImm RegID Immediate
    deriving (Show, Generic, NFDataX)

nop = Move 0 0

data FIFOCommand
    = FIFO_Write Int8
    | FIFO_Read
    | FIFO_Nothing
    deriving (Show, Generic, NFDataX)

type ReadRegs = (RegID, RegID)
type WriteReg = Maybe (Int8, RegID)
type RegisterFile = Vec 3 Int8

decode :: InstructionWord -> Instruction
decode word = if (bit 7)
    then LoadImm immreg imm
    else if not (bit 6)
        then Add reg45 reg23 reg01
        else if (bit 5)
            then if bit 4
                then WriteFIFO reg23
                else ReadFIFO reg23
            else if bit 4
                then Branch reg23 reg01
                else Move reg23 reg01
    where
        bit = testBit word
        -- the .&. is probably unnecessary due to the resize
        imm = resize $ word .&. 0b11111
        immreg = resize $ (word >>> 5) .&. 0b11
        reg01 = resize $ word .&. 0b11
        reg23 = resize $ (word >>> 2) .&. 0b11
        reg45 = resize $ (word >>> 4) .&. 0b11

encode :: Instruction -> InstructionWord
encode instr = case instr of
    ReadFIFO id ->
        0b0110_0000 .|. (resize id <<< 2)
    WriteFIFO id -> 
        0b0111_0000 .|. (resize id <<< 2)
    Add left right dest -> 
        0b0000_0000 .|. (resize left <<< 4) .|. (resize right <<< 2) .|. (resize dest)
    Move from to -> 
        0b0100_0000 .|. (resize from <<< 2) .|. (resize to)
    Branch cond addr -> 
        0b0101_0000 .|. (resize cond <<< 2) .|. (resize addr)
    LoadImm reg imm -> 
        0b1000_0000 .|. (resize reg <<< 5) .|. (resize imm)

empty_regs :: RegisterFile
empty_regs = 0:>1:>0:>Nil

type Program = Vec 32 InstructionWord

test_router_inp :: [(Bool, FIFOCommand)]
test_router_inp = [
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (True, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (True, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing),
        (False, FIFO_Nothing)
    ]

default_prog :: Program
default_prog = map encode $
    (LoadImm 1 17):>
    (WriteFIFO 1):>
    (WriteFIFO 1):>
    (LoadImm 2 1):>
    (WriteFIFO 1):>
    (Add 2 1 1):>
    (WriteFIFO 1):>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>Nil

writes :: FIFOCommand -> Maybe Int8
writes (FIFO_Write a) = Just a
writes _ = Nothing

type DataQueue = Vec 8 Int8
type DataPtr = Unsigned 3

empty_queue :: DataQueue
empty_queue = 1:>2:>3:>4:>5:>6:>7:>8:>Nil

type PacketQueue = Vec 4 Packet
data Packet = Packet Location Int8
    deriving (Show, Generic, NFDataX, BitPack)
type Location = (Unsigned 4, Unsigned 4)

empty_packet_queue :: PacketQueue
empty_packet_queue = zr:>zr:>zr:>zr:>Nil
    where
        zr = Packet (0, 0) 0

empty_loc :: Location
empty_loc = (0, 0)

nothing = Nothing

}

component datapath() {
    input instr_word : InstructionWord
    input reg_a : Int8
    input reg_b : Int8

    state delay = 0 : InstructionWord

    output read_ids : ReadRegs
    output update_regs : WriteReg

    output fifo_cmd : FIFOCommand
    output update_pc : Maybe PC

    instr_out = instruction

    instruction = decode instr_word
    delay' = instr_word

    read_ids = case instruction of
        (ReadFIFO _) -> (0, 0)
        (WriteFIFO reg) -> (0, reg)
        (Add left right _) -> (left, right)
        (Move from _) -> (from, 0)
        (Branch cond addr) -> (cond, addr)
        (LoadImm _ _) -> (0, 0)

    delayed_instr = decode delay

    update_regs = case instruction of
        (ReadFIFO _) -> Nothing -- TODO dit moet natuuk wel ergens ooit
        (WriteFIFO _) -> Nothing
        (Add _ _ dest) -> Just (reg_a + reg_b, dest)
        (Move _ to) -> Just (reg_a, to)
        (Branch _ _) -> Nothing
        (LoadImm reg imm) -> Just (resize imm, reg)

    update_pc = case instruction of
        (Branch _ _) -> if reg_a == 0
            then Just $ resize reg_b
            else Nothing
        _ -> Nothing

    fifo_cmd = case instruction of
        (ReadFIFO _) -> FIFO_Read
        (WriteFIFO _) -> FIFO_Write reg_b
        _ -> FIFO_Nothing

    -- TODO: bouw een FIFO component, zorg ervoor dat de nieuwste read waarde altijd combinatorially leesbaar is, en dat dan de volgende cycle de volgende opgehaald wordt of zo

}

component registers() {
    input read_ids : ReadRegs
    input write : WriteReg

    state regs = empty_regs : RegisterFile

    output reg_a : Int8
    output reg_b : Int8

    regs' =
        case write of
            Just (value, regid) -> if regid == 0
                then regs
                else replace (regid - 1) value regs
            Nothing -> regs

    (reg_a_id, reg_b_id) = read_ids

    reg_a = if reg_a_id == 0
        then 0
        else regs !! (reg_a_id - 1)
    reg_b = if reg_b_id == 0
        then 0
        else regs !! (reg_b_id - 1)
}

component prog_mem() {
    input new_pc : Maybe PC
    state program = default_prog : Program
    state pc = 0 : PC
    output instr : InstructionWord

    instr = program !! pc
    program' = program
    pc' = case new_pc of
        (Just new) -> new
        Nothing -> pc + 1
}


component queue_controller() {
    input proc_cmd : FIFOCommand
    input route_cmd : FIFOCommand
    input router_read : Bool
    
    input outgoing_empty : Bool
    input outgoing_value : Packet
    output outgoing_read : Bool
    output read_packet : Maybe Packet

    input incoming_value : Int8
    input incoming_empty : Bool
    output incoming_read : Bool
    output incoming_write : Bool
    output incoming_datain : Int8
    output read_value : Maybe Int8

    incoming_read = case proc_cmd of
        FIFO_Read -> True && (not incoming_empty)
        _ -> False
    
    incoming_write = case route_cmd of
        FIFO_Write _ -> True

    incoming_datain = case route_cmd of
        FIFO_Write v -> v
        _ -> 0

    outgoing_read = router_read && (not outgoing_empty)

    read_value = if incoming_read
        then Just incoming_value
        else Nothing

    read_packet = trace (show (router_read, not outgoing_empty)) $ if outgoing_read
        then Just outgoing_value
        else Nothing
}

component in_fifo() {
    input datain : Int8
    input write : Bool
    input read : Bool
    state rpntr = 0 : Unsigned 4
    state wpntr = 0 : Unsigned 4
    state elms = empty_queue : DataQueue
    output dataout : Int8
    output empty : Bool
    -- output full : Bool

    -- https://github.com/clash-lang/clash-compiler/blob/master/examples/Fifo.hs
    wpntr' | write     = wpntr + 1
           | otherwise = wpntr
    rpntr' | read      = rpntr + 1
           | otherwise = rpntr

    mask  = resize (maxBound :: Unsigned 3)
    wind  = wpntr .&. mask
    rind  = rpntr .&. mask

    elms' | write     = trace ("Wrote value " L.++ show datain L.++ "to incoming data FIFO") $ replace wind datain elms
          | otherwise = elms

    n = 3

    empty = wpntr == rpntr
    full  = (testBit wpntr n) /= (testBit rpntr n) &&
            (wind == rind)

    dataout = elms !! rind

}

component packet_queue() {
    input datain : Packet
    input write : Bool
    input read : Bool
    state rpntr = 0 : Unsigned 3
    state wpntr = 0 : Unsigned 3
    state elms = empty_packet_queue : PacketQueue
    output dataout : Packet
    output empty : Bool
    -- output full : Bool

    -- https://github.com/clash-lang/clash-compiler/blob/master/examples/Fifo.hs
    wpntr' | write     = wpntr + 1
           | otherwise = wpntr
    rpntr' | read      = rpntr + 1
           | otherwise = rpntr

    mask  = resize (maxBound :: Unsigned 3)
    wind  = wpntr .&. mask
    rind  = rpntr .&. mask

    elms' | write     = trace ("Wrote packet " L.++ show datain L.++ "to packet FIFO") $ replace wind datain elms
          | otherwise = elms

    n = 3

    empty = wpntr == rpntr
    full  = (testBit wpntr n) /= (testBit rpntr n) &&
            (wind == rind)

    dataout = elms !! rind
}

component packet_control() {
    input proc_cmd : FIFOCommand
    state location = nothing : Maybe Location
    state value = nothing : Maybe Int8
    output packet : Packet
    output write : Bool


    -- TODO: herschrijf dit met een nette state ipv het uit justs op te maken
    -- Verder zijn die justs nergens voor nodig, je weet wanneer uit de state wanneer
    -- de packet valid is.
    write = isJust location && isJust value

    input_value = case proc_cmd of
        FIFO_Write v -> Just v
        _ -> Nothing

    input_value' = fromJust input_value

    location' = if isJust location
        then Nothing
        else if isJust input_value
            then Just (resize $ input_value' >>> 4, resize input_value')
            else Nothing
    
    value' = if isJust location
        then if isJust input_value
            then input_value
            else Nothing
        else value

    packet = if isJust location && isJust value
        then (Packet (fromJust location) (fromJust value))
        else (Packet (0, 0) 0)

}