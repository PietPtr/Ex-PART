haskell {

(>>>) :: Bits a => a -> Int -> a
(>>>) = shiftR

(<<<) :: Bits a => a -> Int -> a
(<<<) = shiftL

type Int8 = Unsigned 8
type PC = Unsigned 5

type InstructionWord = Unsigned 8

type RegID = Unsigned 2
type Immediate = Unsigned 5

data Instruction
    = ReadFIFO RegID
    | WriteFIFO RegID
    | Add RegID RegID RegID
    | Move RegID RegID
    | Branch RegID RegID
    | LoadImm RegID Immediate
    deriving (Show, Generic, NFDataX)

nop = Move 0 0

data FIFOCommand
    = FIFO_Write Int8
    | FIFO_Read
    | FIFO_Nothing
    deriving (Show, Generic, NFDataX)

type ReadRegs = (RegID, RegID)
type WriteReg = Maybe (Int8, RegID)
type RegisterFile = Vec 3 Int8

decode :: InstructionWord -> Instruction
decode word = if (bit 7)
    then LoadImm immreg imm
    else if not (bit 6)
        then Add reg45 reg23 reg01
        else if (bit 5)
            then if bit 4
                then WriteFIFO reg23
                else ReadFIFO reg23
            else if bit 4
                then Branch reg23 reg01
                else Move reg23 reg01
    where
        bit = testBit word
        -- the .&. is probably unnecessary due to the resize
        imm = resize $ word .&. 0b11111
        immreg = resize $ (word >>> 5) .&. 0b11
        reg01 = resize $ word .&. 0b11
        reg23 = resize $ (word >>> 2) .&. 0b11
        reg45 = resize $ (word >>> 4) .&. 0b11

encode :: Instruction -> InstructionWord
encode instr = case instr of
    ReadFIFO id ->
        0b0110_0000 .|. (resize id <<< 2)
    WriteFIFO id -> 
        0b0111_0000 .|. (resize id <<< 2)
    Add left right dest -> 
        0b0000_0000 .|. (resize left <<< 4) .|. (resize right <<< 2) .|. (resize dest)
    Move from to -> 
        0b0100_0000 .|. (resize from <<< 2) .|. (resize to)
    Branch cond addr -> 
        0b0101_0000 .|. (resize cond <<< 2) .|. (resize addr)
    LoadImm reg imm -> 
        0b1000_0000 .|. (resize reg <<< 5) .|. (resize imm)

empty_regs :: RegisterFile
empty_regs = 0:>0:>0:>Nil

type Program = Vec 32 InstructionWord

test_router_inp :: [(Bool, FIFOCommand)]
test_router_inp = [
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Write 13),
        (True, FIFO_Write 21),
        (True, FIFO_Nothing),
        (True, FIFO_Write 7),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Write 59),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Write 3),
        (True, FIFO_Write 3),
        (True, FIFO_Write 3),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Write 19),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Write 17),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Write 1),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Write 0),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing),
        (True, FIFO_Nothing)
    ] L.++ (L.take 30 $ L.repeat (True, FIFO_Nothing))

default_prog :: Program
default_prog = map encode $ program ++ repeat (nop)
    where
        program = 
            (LoadImm 1 1):>     -- 0 Load non-zero value in reg1 to avoid jumping
            (LoadImm 3 7):>     -- 1 Set jump addr to write sequence
            (ReadFIFO 1):>      -- 2 read from fifo
            (Branch 1 3):>      -- 3 if we receive zero, jump to write sequence
            (Add 1 2 2):>       -- 4 otherwise, add input to sum reg
            (LoadImm 3 1):>     -- 5 Set jump addr to start of program
            (Branch 0 3):>      -- 6 Always jump to address 1, i.e. read again
            
            (LoadImm 3 17):>    -- 7 Set destination to (1, 1)
            (WriteFIFO 3):>     -- 8 write destination
            (WriteFIFO 2):>     -- 9 write sum value
            (LoadImm 3 11):>    -- 10 set jump addr to end program
            (Branch 0 3):>      -- 11 End program, infinite loop
            Nil


writes :: FIFOCommand -> Maybe Int8
writes (FIFO_Write a) = Just a
writes _ = Nothing

type DataQueue = Vec 8 Int8
type DataPtr = Unsigned 3

empty_queue :: DataQueue
empty_queue = 1:>2:>3:>4:>5:>6:>7:>8:>Nil

type PacketQueue = Vec 4 Packet
data Packet = Packet Location Int8
    deriving (Show, Generic, NFDataX, BitPack)
type Location = (Unsigned 4, Unsigned 4)

empty_packet_queue :: PacketQueue
empty_packet_queue = zr:>zr:>zr:>zr:>Nil
    where
        zr = Packet (0, 0) 0

empty_loc :: Location
empty_loc = (0, 0)

nothing = Nothing

data PacketControlState = Idle | GotLoc Location | Ready Location Int8
    deriving (Show, Generic, NFDataX)

int2loc :: Int8 -> Location
int2loc v = (resize $ v >>> 4, resize v)


}

component datapath() {
    input instr_word : InstructionWord
    input reg_a : Int8
    input reg_b : Int8
    input fifo_val : Maybe Int8

    state delay = 0 : InstructionWord
    state pc = 0 : PC

    output read_ids : ReadRegs
    output update_regs : WriteReg

    output fifo_cmd : FIFOCommand
    output pc_out : PC

    instr_out = instruction

    instruction = decode instr_word
    delay' = instr_word

    read_ids = case instruction of
        (ReadFIFO _) -> (0, 0)
        (WriteFIFO reg) -> (0, reg)
        (Add left right _) -> (left, right)
        (Move from _) -> (from, 0)
        (Branch cond addr) -> (cond, addr)
        (LoadImm _ _) -> (0, 0)

    delayed_instr = decode delay

    update_regs = case instruction of
        (ReadFIFO dest) -> case fifo_val of
            Just v -> Just (v, dest)
            Nothing -> Nothing
        (WriteFIFO _) -> Nothing
        (Add _ _ dest) -> Just (reg_a + reg_b, dest)
        (Move _ to) -> Just (reg_a, to)
        (Branch _ _) -> Nothing
        (LoadImm reg imm) -> Just (resize imm, reg)

    update_pc = case instruction of
        (Branch _ _) -> if reg_a == 0
            then Just $ resize reg_b
            else Nothing
        (ReadFIFO _) -> case fifo_val of
            Nothing -> Just pc


    fifo_cmd = case instruction of
        (ReadFIFO _) -> FIFO_Read
        (WriteFIFO _) -> FIFO_Write reg_b
        _ -> FIFO_Nothing


    pc' = case instruction of
        (Branch _ _) -> if reg_a == 0
            then resize reg_b
            else pc + 1
        (ReadFIFO _) -> case fifo_val of
            Nothing -> pc -- block on no value
            _ -> pc + 1
        _ -> pc + 1

    pc_out = pc

}

component registers() {
    input read_ids : ReadRegs
    input write : WriteReg

    state regs = empty_regs : RegisterFile

    output reg_a : Int8
    output reg_b : Int8

    regs' =
        case write of
            Just (value, regid) -> if regid == 0
                then regs
                else replace (regid - 1) value regs
            Nothing -> regs

    (reg_a_id, reg_b_id) = read_ids

    reg_a = if reg_a_id == 0
        then 0
        else regs !! (reg_a_id - 1)
    reg_b = if reg_b_id == 0
        then 0
        else regs !! (reg_b_id - 1)
}

component prog_mem() {
    input pc : PC
    state program = default_prog : Program
    output instr : InstructionWord

    instr = program !! pc
    program' = program
}


component queue_controller() {
    input proc_cmd : FIFOCommand
    input route_cmd : FIFOCommand
    input router_read : Bool
    
    input outgoing_empty : Bool
    input outgoing_value : Packet
    output outgoing_read : Bool
    output read_packet : Maybe Packet

    input incoming_value : Int8
    input incoming_empty : Bool
    output incoming_read : Bool
    output incoming_write : Bool
    output incoming_datain : Int8
    output read_value : Maybe Int8

    incoming_read = case proc_cmd of
        FIFO_Read -> True && (not incoming_empty)
        _ -> False
    
    incoming_write = case route_cmd of
        FIFO_Write _ -> True
        _ -> False

    incoming_datain = case route_cmd of
        FIFO_Write v -> v
        _ -> 0

    outgoing_read = router_read && (not outgoing_empty)

    read_value = if incoming_read
        then Just incoming_value
        else Nothing

    read_packet = if outgoing_read
        then Just outgoing_value
        else Nothing
}

component in_fifo() {
    input datain : Int8
    input write : Bool
    input read : Bool
    state rpntr = 0 : Unsigned 4
    state wpntr = 0 : Unsigned 4
    state elms = empty_queue : DataQueue
    output dataout : Int8
    output empty : Bool
    -- output full : Bool

    -- https://github.com/clash-lang/clash-compiler/blob/master/examples/Fifo.hs
    wpntr' | write     = wpntr + 1
           | otherwise = wpntr
    rpntr' | read      = rpntr + 1
           | otherwise = rpntr

    mask  = resize (maxBound :: Unsigned 3)
    wind  = wpntr .&. mask
    rind  = rpntr .&. mask

    elms' | write     = replace wind datain elms
          | otherwise = elms

    n = 3

    empty = wpntr == rpntr
    full  = (testBit wpntr n) /= (testBit rpntr n) &&
            (wind == rind)

    dataout = elms !! rind

}

component packet_queue() {
    input datain : Packet
    input write : Bool
    input read : Bool
    state rpntr = 0 : Unsigned 3
    state wpntr = 0 : Unsigned 3
    state elms = empty_packet_queue : PacketQueue
    output dataout : Packet
    output empty : Bool
    -- output full : Bool

    -- https://github.com/clash-lang/clash-compiler/blob/master/examples/Fifo.hs
    wpntr' | write     = wpntr + 1
           | otherwise = wpntr
    rpntr' | read      = rpntr + 1
           | otherwise = rpntr

    mask  = resize (maxBound :: Unsigned 2)
    wind  = wpntr .&. mask
    rind  = rpntr .&. mask

    elms' | write     = replace wind datain elms
          | otherwise = elms

    n = 3

    empty = wpntr == rpntr
    full  = (testBit wpntr n) /= (testBit rpntr n) &&
            (wind == rind)

    dataout = elms !! rind
}

component packet_control() {
    input proc_cmd : FIFOCommand
    state ctrl_state = Idle : PacketControlState
    output packet : Packet
    output write : Bool


    ctrl_state' = case ctrl_state of
        Idle -> case proc_cmd of
            (FIFO_Write v) -> GotLoc (int2loc v)
            _ -> Idle
        GotLoc l -> case proc_cmd of
            (FIFO_Write v) -> Ready l v
            _ -> GotLoc l
        Ready _ _ -> Idle
    
    write = case ctrl_state of
        Ready _ _ -> True
        _ -> False
    
    packet = case ctrl_state of
        Ready l v -> Packet l v
        _ -> Packet (0, 0) 0

}