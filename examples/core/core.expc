haskell {

(>>>) :: Bits a => a -> Int -> a
(>>>) = shiftR

(<<<) :: Bits a => a -> Int -> a
(<<<) = shiftL

type Int8 = Unsigned 8
type PC = Unsigned 5

type InstructionWord = Unsigned 8

type RegID = Unsigned 2
type Immediate = Unsigned 5

data Instruction
    = ReadFIFO RegID
    | WriteFIFO RegID
    | Add RegID RegID RegID
    | Move RegID RegID
    | Branch RegID RegID
    | LoadImm RegID Immediate
    deriving (Show, Generic, NFDataX)

nop = Move 0 0

data FIFOCommand
    = FIFO_Write Int8
    | FIFO_Read
    | FIFO_Nothing
    deriving (Show, Generic, NFDataX)

type ReadRegs = (RegID, RegID)
type WriteReg = Maybe (Int8, RegID)
type RegisterFile = Vec 3 Int8

decode :: InstructionWord -> Instruction
decode word = if (bit 7)
    then LoadImm immreg imm
    else if not (bit 6)
        then Add reg45 reg23 reg01
        else if (bit 5)
            then if bit 4
                then WriteFIFO reg23
                else ReadFIFO reg23
            else if bit 4
                then Branch reg23 reg01
                else Move reg23 reg01
    where
        bit = testBit word
        -- the .&. is probably unnecessary due to the resize
        imm = resize $ word .&. 0b11111
        immreg = resize $ (word >>> 5) .&. 0b11
        reg01 = resize $ word .&. 0b11
        reg23 = resize $ (word >>> 2) .&. 0b11
        reg45 = resize $ (word >>> 4) .&. 0b11

encode :: Instruction -> InstructionWord
encode instr = case instr of
    ReadFIFO id ->
        0b0110_0000 .|. (resize id <<< 2)
    WriteFIFO id -> 
        0b0111_0000 .|. (resize id <<< 2)
    Add left right dest -> 
        0b0000_0000 .|. (resize left <<< 4) .|. (resize right <<< 2) .|. (resize dest)
    Move from to -> 
        0b0100_0000 .|. (resize from <<< 2) .|. (resize to)
    Branch cond addr -> 
        0b0101_0000 .|. (resize cond <<< 2) .|. (resize addr)
    LoadImm reg imm -> 
        0b1000_0000 .|. (resize reg <<< 5) .|. (resize imm)

empty_regs :: RegisterFile
empty_regs = 0:>1:>0:>Nil

type Program = Vec 32 InstructionWord

default_prog :: Program
default_prog = map encode $
    (LoadImm 1 17):>
    (Add 1 2 2):>
    (WriteFIFO 2):>
    (LoadImm 3 5):>
    (Branch 2 3):>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>
    nop:>Nil

writes :: FIFOCommand -> Maybe Int8
writes (FIFO_Write a) = Just a
writes _ = Nothing

}

component datapath() {
    input instr_word : InstructionWord
    input reg_a : Int8
    input reg_b : Int8

    state delay = 0 : InstructionWord

    output read_ids : ReadRegs
    output update_regs : WriteReg

    output fifo_cmd : FIFOCommand
    output update_pc : Maybe PC

    instr_out = instruction

    instruction = decode instr_word
    delay' = instr_word

    read_ids = case instruction of
        (ReadFIFO _) -> (0, 0)
        (WriteFIFO reg) -> (0, reg)
        (Add left right _) -> (left, right)
        (Move from _) -> (from, 0)
        (Branch cond addr) -> (cond, addr)
        (LoadImm _ _) -> (0, 0)

    delayed_instr = decode delay

    update_regs = case instruction of
        (ReadFIFO _) -> Nothing -- TODO dit moet natuuk wel ergens ooit
        (WriteFIFO _) -> Nothing
        (Add _ _ dest) -> Just (reg_a + reg_b, dest)
        (Move _ to) -> Just (reg_a, to)
        (Branch _ _) -> Nothing
        (LoadImm reg imm) -> Just (resize imm, reg)

    update_pc = case instruction of
        (Branch _ _) -> if reg_a == 0
            then Just $ resize reg_b
            else Nothing
        _ -> Nothing

    fifo_cmd = case instruction of
        (ReadFIFO _) -> FIFO_Read
        (WriteFIFO _) -> FIFO_Write reg_b
        _ -> FIFO_Nothing

    -- TODO: Bouw het program memory eerst maar
    -- TODO: bouw een FIFO component, zorg ervoor dat de nieuwste read waarde altijd combinatorially leesbaar is, en dat dan de volgende cycle de volgende opgehaald wordt of zo

}

component registers() {
    input read_ids : ReadRegs
    input write : WriteReg

    state regs = empty_regs : RegisterFile

    output reg_a : Int8
    output reg_b : Int8

    regs' =
        case write of
            Just (value, regid) -> if regid == 0
                then regs
                else replace (regid - 1) value regs
            Nothing -> regs

    (reg_a_id, reg_b_id) = read_ids

    reg_a = if reg_a_id == 0
        then 0
        else regs !! (reg_a_id - 1)
    reg_b = if reg_b_id == 0
        then 0
        else regs !! (reg_b_id - 1)
}

component prog_mem() {
    input new_pc : Maybe PC
    state program = default_prog : Program
    state pc = 0 : PC
    output instr : InstructionWord

    instr = program !! pc
    program' = program
    pc' = case new_pc of
        (Just new) -> new
        Nothing -> pc + 1
}