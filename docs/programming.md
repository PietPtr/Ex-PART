In this guide as much as possible information on how to _program a design_ in Ex-PART is provided. Since Ex-PART was developed for a Master thesis, there are quite some hacks and pitfalls you may encounter. Furthermore, Ex-PART has quite a lot of features to use when programming.

This guide fully focusses on allowing you to design hardware in Ex-PART. If anything goes wrong (crashes, produces unexpected results, etc), take a look at the maintenance manual to find out how to continue, and where you may need to apply a fix.

Check Github's table of content feature for Markdown files to see what you can find here.


# General Remarks

- Haskell syntax highlighting works quite well with Ex-PART, it's not perfect but as there was not really a consistent grammar available no custom syntax highlighting was developed.

- Parse errors are usually not very clear, see issue [#10](https://github.com/PietPtr/Ex-PART/issues/10).

- Parse errors may occur when spaces or other whitespace occurs in the wrong place. The parser does not allow some kinds of statements to end with whitespace, so a line ending with a space may result in a parse error.

- Parse errors will also occur when the character '}' occurs, since this character is used to detect that a block (like a `haskell` block, as will be explained later). This character occurs in Haskell multiline comments and in records, hence these cannot be used in an Ex-PART design.

- Bitwidths of types are not determined automatically. In `parser/Types.hs` a switch statement is located that matches the name of a type to a bitwidth. Usually this becomes clear by the error "cannot find bitwdith for type <Type>". This means that if you use any type that it is not listed there, or define a type synonym of the same name but with a different bitwidth that is defined there, Ex-PART will not function correctly. See also issue [#2](https://github.com/PietPtr/Ex-PART/issues/2). If you want to add a type, either solve this problem correctly by looking at how Clash determines type bitwidths, or simply add / modify the case statement.

- Scopes are very unclear. No design time was given to exact scoping of variables, and in practice there are several namespaces in Ex-PART (even though they were not necessarily built on purpose). There is the namespace of component/system instantiations, these are given a name such that they can be referred to in coordinate expressions. These names are globally referencable in coordinate expressions, but no error will be given if they do overlap, simply the 'first' will be returned. Then there is a namespace of system and component names, which is used to designate the kind of system instantiated when instantiating something. This is also globally referenceable. If anything goes wrong in scopes, it's probably because they were not designed at all, try renaming variables such that everything has a unique name and see if that goes better. Furhermore, I have not checked whether scopes in the simulation and in synthesis behave the exactly the same. See also [#11](https://github.com/PietPtr/Ex-PART/issues/11).

- The feature list below also details some hacks, tips, and tricks for these features that may ease development or help understanding why something behaves unexpectedly.



# Design Feedback

## Visualisation

The Python program `visualisers/main.py` is a generic visualizer for two types of output JSON files of Ex-PART. It can visualize component placement (taken from the generated `locations.json`) and placement of slices onto the FPGA taken from an output JSON generated by nextpnr (consistently named `bitstream.json` throughout all Ex-PART builds). `visualize.py` expects one argument: the folder in which it should search for JSONs. When none are found or the folder does not exist, the program simply shows an empty screen. As soon as either one of the JSONs is available it will be drawn by the visualizer. To differentiate between location information as given in the expi and placement information as generated by Ex-PART, expi colors are more muted and drawn as a border. If the information is available, a legend will be drawn in the topright corner. Indicators in the bottom right corner show which files are loaded.

### Example commands

`python visualizers/visualize.py project`

Shows bitstreams and locations in project folder `project/`, as soon as they are generated.

`python visualizers/visualize.py project/builds/component/`

Shows out-of-context pnr result of component `component` in project `project`, as soon as it is generated.

`python visualizers/visualize.py project_monolithic`

Shows bitstream as generated by the monolithic flow for project `project`. 

The visualizer can always be run and does not need the folder to exist, it simply waits until the folder contains visualizable files. File loaded indicators in the bottom right corner indicate which visualisable files were found.

Tips:

- The visualiser will try to visualize any folder that contains either a `locations.json` or a `bitstream.json`, so it also works on the output directories of the monolithic, hierarchic, and resource flow. 

- There is a switch, -c, to enable showing connections that leave a component. This will render every connection that goes from one cell in a component to a cell in some _other_ component. 

- There is also a switch, -p, to enable a simpler view that shows the full ECP5 at once.

- The visualiser is built entirely for the 85k version of the ECP5. More information on that version of the ECP5 can be found [here](http://yosyshq.net/prjtrellis-db/). For more comments see issue [#9](https://github.com/PietPtr/Ex-PART/issues/9).

## Metric Analysis

All the tools Ex-PART runs to obtain results emit outputs and errors that may be valuable for debugging and evaluating a design. Since these are spread all over the place, a script gathering these metrics is available in the root directory: `analyze.py`. Simply run it with the name of an Ex-PART output directory as its argument and it will search all available logs for metrics. If it can't find any it will print it as a dash. If hierarchic and monolithic output folders are available it will print the metrics in a table to easily compare them. Just as the visualiser, this script can be run on directories in the `builds/` directory to gain insights into resources used by components.

## The Output Directory

A ton of information is available in the output directory, all the logs, intermediate files, simulation files, etcetera.

# Thorough Explanation of a basic Ex-PART program


In this chapter we will walk through the collatz example (`examples/collatz/`). This file describes a piece of hardware that keeps a number in a 16 bit register, and applies the rules of the [Collatz conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture), i.e. if the number in the register is even it is divided by two, and if it is odd it is multiplied by three and one is added to it. 

TODO: add the diagram from the paper.

## `.expc` file

Now, an explanation of the `.expc` file:

```haskell
haskell {
(>>>) :: Bits a => a -> Int -> a
(>>>) = shiftR

(<<<) :: Bits a => a -> Int -> a
(<<<) = shiftL

type Value = Unsigned 16

}
```
In a `haskell` block arbitrary Haskell code can be added to the design. Each component has access to these definitions. Do not indent them as they are copied straight to a `Definitions.hs` file. Define helper functions, type and data definitions, and debug stuff here.

```haskell
component router() {
    input val : Value
    output odd : Maybe Value
    output even : Maybe Value

    even = if testBit val 0 then Nothing else Just val
    odd  = if testBit val 0 then Just val else Nothing
}
```
A component definition. After the keyword `component` the name of the component followed by `()` is defined. The parentheses are necessary as a feature was planned to allow generics to be passed to a component. This feature has not been implemented, but some support for it remains there in the parser. 

The first lines of a component are the input, output, and state definitions. This component happens to be a combinational component: it has no state. This component receives a 16-bit value (namely `val`, of type `Value`, which was defined to be an `Unsigned 16` in the `haskell` block from earlier). It has two outputs, both of type `Maybe Value`.


```haskell
component onEven() {}
component onOdd() {}
component merger() {}
```

These component are also all combinational, so not much news happens here, so their implementation is ommitted.

```haskell
component control() {
    input next_val : Value
    input set_val : Maybe Value
    state last_val = 0 : Value
    output result_value : Value

    last_val' = case set_val of
        Just new_value -> new_value
        Nothing -> next_val

    result_value = last_val
}
```
This is a component with state. Its state is defined in the fourth line of the example above. It is given a type just like the inputs and outputs. Additionally an initial value is supplied, namely `0`.

To define the state transition, an expression is defined for `last_val'`. Notice that this expression can depend on any of the inputs, and the previous state. It can also depend on some other state, or their next states, as long as they do not form a mutually recursive dependence. 

## `.expi` file

With the components defined, the `.expi` file can be written to layout those component in a hierarchy.

```haskell
system in (6, 5) at (2, 2) {

```
The top-level system is called `system`, takes up an area of six by five, and is located at position (2, 2) on the ECP5. This coordinate system is zero-indexed, and uses the same system as the [HTML documentation of the ECP5](http://yosyshq.net/prjtrellis-db/).

The size of systems is not checked by Ex-PART, if you specify (1, 1) here it may work is well. Where it is taken into account is when any of the components _refer_ to this value, that is if a component is placed at e.g. `(system.x, 0)`. This size is currently not in any way inferable, if you resize components in a hierarchy and you need to use an accurate size for the system, you need to update the system size manually. See also issue [#12](https://github.com/PietPtr/Ex-PART/issues/12) on inferable sizes.

```haskell
    input setting : Maybe Value
    output result : Value
```
The I/O of the top-level system. As the input we define a setting, this `Maybe Value` can set the value in the register to which the Collatz conjecture rules must be applied. `control` is a component that has an input of type `Maybe Value` for exactly this purpose, so once that component is instantiated we must route this input to that component.

Since this is I/O of the _top_-level system, this is also the I/O that must be constrained in the `.lpf` file. 

```haskell
    controller is control in (6, 1) at (0, 0)
```
The `control` component is instantiated. It is given the name 'controller', an area of six by one, and the location _(0, 0)_. This location is relative to the system it is a child of, so on the FPGA this component will be located at (2, 2).

The size could also have been defined as `(system.w, 1)`, for example.

```haskell
    controller.set_val<-setting
    controller.result_value->result
```
The controller's inputs are linked to the inputs of its parent system. Notice that the arrow notation can go both ways. A port of the control component is referred to by writing the _name_ of the instance of the component, followed by a period, and then the port name. 

Local system ports do not need this period-syntax, they are simply referred to by name, as is done with `setting` and `result`.

With these statements the system I/O port setting and result are connected to the controller, so that the controller component drives/is driven by the FPGA I/O ports as intended.


```haskell
    collatzer in (controller.w, 4) at (0, controller.h) {
```
A subsystem is defined. At this point it is probably a good idea to view the file this comes from, as the indentation here will make it much clearer that this is a _sub_system. 

```haskell
        input val_in : Value
        output val_out : Value

        router is router in (1, onOdd.h + onEven.h) at (0, 0)
        onOdd is onOdd in (collatzer.w - 2, 2) at (collatzer.x + 1, 0)
        onEven is onEven in (onOdd.w, onOdd.h) at (onOdd.x, onOdd.h)
        merger is merger in (1, onOdd.h + onEven.h) at (onOdd.x + onOdd.w, 0)

        router.val<-val_in
        router.odd->onOdd.val
        router.even->onEven.val
        onOdd.res->merger.vo
        onEven.res->merger.ve
        merger.res->val_out
    }

    collatzer.val_in<-controller.result_value
    collatzer.val_out->controller.next_val
}
```

# Simulation with Clash



# Bitstream Generation

# Feature List

## Comments

## `.expc` file

## `haskell` block

## Component definition

### I/O ports and state

### Transition statements

## `.expi` file

## Coordinates and Sizes

## System Definitions

### I/O ports

### Subsystems

## Component Instantiation

## Port connection

## Constant Drivers

## Repeat statement

## Chain statement

## Multiconnections

## Unplaced Systems

## System Instantiation



