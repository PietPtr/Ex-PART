
# General Remarks

- Haskell syntax highlighting works quite well with Ex-PART, it's not perfect but as there was not really a consistent grammar available no custom syntax highlighting was developed.

- Parse errors are usually not very clear, see issue [#10](https://github.com/PietPtr/Ex-PART/issues/10).

- Parse errors may occur when spaces or other whitespace occurs in the wrong place. The parser does not allow some kinds of statements to end with whitespace, so a line ending with a space may result in a parse error.

- Parse errors will also occur when the character '}' occurs, since this character is used to detect that a block (like a `haskell` block, as will be explained later). This character occurs in Haskell multiline comments and in records, hence these cannot be used in an Ex-PART design.

- Bitwidths of types are not determined automatically. In `parser/Types.hs` a switch statement is located that matches the name of a type to a bitwidth. Usually this becomes clear by the error "cannot find bitwdith for type <Type>". This means that if you use any type that it is not listed there, or define a type synonym of the same name but with a different bitwidth that is defined there, Ex-PART will not function correctly. See also issue [#2](https://github.com/PietPtr/Ex-PART/issues/2). If you want to add a type, either solve this problem correctly by looking at how Clash determines type bitwidths, or simply add / modify the case statement.

- Scopes are very unclear. No design time was given to exact scoping of variables, and in practice there are several namespaces in Ex-PART (even though they were not necessarily built on purpose). There is the namespace of component/system instantiations, these are given a name such that they can be referred to in coordinate expressions. These names are globally referencable in coordinate expressions, but no error will be given if they do overlap, simply the 'first' will be returned. Then there is a namespace of system and component names, which is used to designate the kind of system instantiated when instantiating something. This is also globally referenceable. If anything goes wrong in scopes, it's probably because they were not designed at all, try renaming variables such that everything has a unique name and see if that goes better. Furhermore, I have not checked whether scopes in the simulation and in synthesis behave the exactly the same. See also [#11](https://github.com/PietPtr/Ex-PART/issues/11).

- The feature list below also details some hacks, tips, and tricks for these features that may ease development or help understanding why something behaves unexpectedly.



# Design Feedback

## Visualisation

The Python program `visualisers/main.py` is a generic visualizer for two types of output JSON files of Ex-PART. It can visualize component placement (taken from the generated `locations.json`) and placement of slices onto the FPGA taken from an output JSON generated by nextpnr (consistently named `bitstream.json` throughout all Ex-PART builds). `visualize.py` expects one argument: the folder in which it should search for JSONs. When none are found or the folder does not exist, the program simply shows an empty screen. As soon as either one of the JSONs is available it will be drawn by the visualizer. To differentiate between location information as given in the expi and placement information as generated by Ex-PART, expi colors are more muted and drawn as a border. If the information is available, a legend will be drawn in the topright corner. Indicators in the bottom right corner show which files are loaded.

### Example commands

`python visualizers/visualize.py project`

Shows bitstreams and locations in project folder `project/`, as soon as they are generated.

`python visualizers/visualize.py project/builds/component/`

Shows out-of-context pnr result of component `component` in project `project`, as soon as it is generated.

`python visualizers/visualize.py project_monolithic`

Shows bitstream as generated by the monolithic flow for project `project`. 

The visualizer can always be run and does not need the folder to exist, it simply waits until the folder contains visualizable files. File loaded indicators in the bottom right corner indicate which visualisable files were found.

Tips:

- The visualiser will try to visualize any folder that contains either a `locations.json` or a `bitstream.json`, so it also works on the output directories of the monolithic, hierarchic, and resource flow. 

- There is a switch, -c, to enable showing connections that leave a component. This will render every connection that goes from one cell in a component to a cell in some _other_ component. 

- There is also a switch, -p, to enable a simpler view that shows the full ECP5 at once.

- The visualiser is built entirely for the 85k version of the ECP5. More information on that version of the ECP5 can be found [here](http://yosyshq.net/prjtrellis-db/). For more comments see issue [#9](https://github.com/PietPtr/Ex-PART/issues/9).

## Metric Analysis

All the tools Ex-PART runs to obtain results emit outputs and errors, that may be valuable for debugging and evaluating a design. Since these are spread all over the place, a script gathering these metrics is available in the root directory: `analyze.py`. Simply run it with the name of an Ex-PART output directory as its argument and it will search all available logs for metrics. If it can't find any it will print it as a dash. If hierarchic and monolithic output folders are available it will print the metrics in a table to easily compare them. Just as the visualiser, this script can be run on directories in the `builds/` directory to gain insights into resources used by components.

# Explanation of a basic Ex-PART program

In this chapter we will walk through the collatz example (`examples/collatz/`). This file describes a piece of hardware that keeps a number in a 16 bit register, and applies the rules of the [Collatz conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture), i.e. if the number in the register is even it is divided by two, and if it is odd it is multiplied by three and one is added to it. 

TODO: add the diagram from the paper.

Now, an explanation of the `.expc` file:

```
haskell {
(>>>) :: Bits a => a -> Int -> a
(>>>) = shiftR

(<<<) :: Bits a => a -> Int -> a
(<<<) = shiftL

type Value = Unsigned 16

}
```
In a `haskell` block arbitrary Haskell code can be added to the design. Each component has access to these definitions. Do not indent them as they are copied straight to a `Definitions.hs` file. Define helper functions, type and data definitions, and debug stuff here.

```
component router() {
    input val : Value
    output odd : Maybe Value
    output even : Maybe Value

    even = if testBit val 0 then Nothing else Just val
    odd  = if testBit val 0 then Just val else Nothing
}
```
A component definition. After the keyword `component` the name of the component followed by `()` is defined. The parentheses are necessary as a feature was planned to allow generics to be passed to a component. This feature has not been implemented, but some support for it remains there in the parser. 

The first lines of a component are the input, output, and state definitions. This component happens to be a combinational component: it has no state. This component receives a 16-bit value (namely `val`, of type `Value`, which was defined to be an `Unsigned 16` in the `haskell` block from earlier). It has two outputs, both of type `Maybe Value`.


```
component onEven() {
    input val : Maybe Value
    output res : Maybe Value

    res = case val of
        Just v -> Just $ v >>> 1
        Nothing -> Nothing
}

component onOdd() {
    input val : Maybe Value
    output res : Maybe Value

    res = case val of
        Just v -> Just $ (v <<< 1 + v) + 1
        Nothing -> Nothing
}

component merger() {
    input vo : Maybe Value
    input ve : Maybe Value
    output res : Value
    
    res = case vo of
        Just v -> v
        Nothing -> case ve of
            Just v -> v
            Nothing -> 0
}

component control() {
    input next_val : Value
    input set_val : Maybe Value
    state last_val = 0 : Value
    output result_value : Value

    last_val' = case set_val of
        Just new_value -> new_value
        Nothing -> next_val

    result_value = last_val
}
```

# Feature List

