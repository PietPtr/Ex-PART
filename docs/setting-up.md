# Prerequisites

Ex-PART is built on exactly these versions of software involved, any older or newer may work, but probably won't as Ex-PART uses features which are changed often. Find here all used software and their `--version` return strings.

> Yosys version 0.10.0:
> 
> 
> `Yosys 0.10.0 (git sha1 UNKNOWN, gcc 11.1.0 -march=x86-64 -mtune=generic -O2 -fno-plt -fPIC -Os)`
> 

> nextpnr at git hash `dd637643`
> 
> 
> `nextpnr-ecp5 -- Next Generation Place and Route (Version dd637643)`
> 

> Clash version 1.4.6
> 
> 
> `Clash, version 1.4.6 (using clash-lib, version: 1.4.6)`
> 

> Boost 1.76.0-1
> 
> 
> `extra/boost-libs 1.76.0-1 (2.3 MiB 9.3 MiB) (Installed)`
> 

> Python 3.9.7
> 
> 
> `Python 3.9.7`
> 

> Pygame 2.0.1
> 
> 
> `pygame 2.0.1 (SDL 2.0.16, Python 3.9.7)`
> 

# Project directory structure

A project called 'project' is best structured as follows:

```
project
├── project.expc
├── project.expi
└── project.lpf
```

It is possible to use different names for the expc/expi/lpf file, but using the same allows the use of the shorthand `make` function to build a project.

# Running Ex-PART

## ghci

Ex-PART does not come with a nice `main` function, instead it is generally run through `ghci`. To run it, navigate to the root directory of this repository and run:

```
ghci -iparser -iclash-generator -ijson-builder -iyosys -inextpnr -ielaboration -icompiler Main.hs
```

As far as I am aware, Ex-PART does not have any dependencies that do not ship with Haskell by default. A nicer way to structure and run all this is by using Cabal or Stack, see issue [#6](https://github.com/PietPtr/Ex-PART/issues/6). 

# Flows

## Running flows

Ex-PART comes with several 'compilation flows', these are basically build scripts that build the project using different approaches. All flows can be found in `/compiler/Compiler.hs` and have type `Flow`. A flow can be run by itself, it always requires four arguments: the `.expc` file, the `.expi` file, the constraints (`.lpf`) file, and the output directory. If the first three files have the same name (as suggested in the previous section) they can be run with the `make :: Flow -> String -> IO ()` function, which takes a flow, a project name of one of the projects in the examples, and runs the flow for that project.

Compile flows often change directory. When a compile flow crashes the directory is not reset to the main directory. Use `:r` to reset this.

## Flow documentation

Here all available flows are listed, including their caveats and features.

### `clean`

The clean flow rebuilds the entire project. It clears the output directory of all files generated by previous runs and rebuilds everything from scratch. 

### `auto`

Since the clean flow can take quite some time (rerunning Clash on all components takes forever), the auto flow can be used. The idea of this flow is that it detects which components must be rebuilt (if any), and if the connections have to be rebuilt. 

This detection is not always very good, as detailed in [#7](https://github.com/PietPtr/Ex-PART/issues/7).

### `monolithic`

Builds the project as a monolithic design: it produces Clash.hs (normally used for synthesis), which has every function inlined by default. This file is converted to one enormous Verilog file with clash, synthesized with Yosys, and placed and routed without any placement constraints by nextpnr. 

### `hierarchic`

Similar process as the monolithic flow, but adds annotations to Clash.hs to _not_ inline every function. This produces a hierachic Verilog project that is sythesized by Yosys and placed and routed without placement constraints by nextpnr.

### `resource`

For every component in the design, produces a clash file, synthesizes that (so just the component is synthesized), and places and routes it using the `--out-of-context` switch of nextpnr. This option does not route the ports of the component to I/O ports. This flow is used to investigate resource usage of the components used in the design to provide information necessary during layout. This is the flow where you would discover how much area one component needs (at least).

### `resource'`

The same as `resource`, but additionally takes a list of strings (so call it as e.g. `make (resource' ["component1", "component2"]) "project"`) of the names of the components for which it should run the resource flow. This is a nice flow to have when you do not want to resynthesize every component after adding some new ones.

### `sim`

Only rebuilds `Clash.hs`. Useful when the expc/expi has changed and only the functional correctness of the design must be checked.

### `location`

Only rebuilds `location.json`. This may be useful when the auto flow seems broken ([#7](https://github.com/PietPtr/Ex-PART/issues/7)) and only the expi file has changed.

### `pnr`

Only runs nextpnr on the project. Assumes that `locations.json` and `synthesized.json` are both available. Useful when placement has failed and a subtly different placement is tried (in tandem with the `location` flow).

